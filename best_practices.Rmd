---
title: "Best practices to analyze WGBS data with methrix"
author: "Anand Mayakonda, Maximilian Schönung, Joschka Hey, Rajbir Batra, Kristin Köhler, Daniel Lipka, Christoph Plass, Pavlo Lutsik, Reka Toth"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    self_contained: yes
    highlight: pygments
vignette: >
  %\VignetteIndexEntry{Methrix tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

This vignette describes basic usage of the package intended to process several large [bedgraph](https://genome.ucsc.edu/goldenPath/help/bedgraph.html) files in R. `Methrix` provides set of function which allows easy importing of various flavors of bedgraphs generated by methylation callers, and many downstream analysis to be performed on large matrices.

```{r message=FALSE, warning=FALSE}
#Load library
library(methrix)
```

```{r message=FALSE, warning=FALSE}
#Genome of your preference to work with
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

library(BiocManager)

if(!requireNamespace("BSgenome.Hsapiens.UCSC.hg19")) {
BiocManager::install("BSgenome.Hsapiens.UCSC.hg19")
}
library(BSgenome.Hsapiens.UCSC.hg19) 
```

# Processing

## CpG annotation 
As a first step, we need a list of CpG sites in the respective genome. The CpG sites are listed using the respective [Bsgenome](https://bioconductor.org/packages/release/bioc/html/BSgenome.html) annotation package. The `read_bedgraph` function is also able to extract CpG sites on it's own, however, it might be beneficial to do it separately. 

```{r ref_data}
hg19_cpgs <- suppressWarnings(methrix::extract_CPGs(ref_genome = "BSgenome.Hsapiens.UCSC.hg19"))
```

## Sample annotation 
An annotation table is also necessary to perform analyses. The data will be added to the methrix object, as a `colData` slot. 

```{r sample_anno}

#Example bedgraph files
bdg_files <- list.files(
  path = system.file('extdata', package = 'methrix'),
  pattern = "*bedGraph\\.gz$",
  full.names = TRUE
)

sample_anno <- data.frame(
  row.names = gsub(
    pattern = "\\.bedGraph\\.gz$",
    replacement = "",
    x = basename(bdg_files)
  ),
  Condition = c("cancer", 'cancer', "normal", "normal"),
  Pair = c("pair1", "pair2", "pair1", "pair2"),
  stringsAsFactors = FALSE
)
knitr::kable(sample_anno)
```


## Reading bedGraph files
`read_bedgraphs` function is a versatile bedgraph reader intended to import bedgraph files generated virtually by any sort of methylation calling program. It requires user to provide indices for chromosome names, start position and other required fields. There are also presets available to import `bedgraphs` from most common programs such as `Bismark` (.cov format), `MethylDackel`, and `MethylcTools`. In this case, there is no need to define e.g. `chr_idx` `start_idx` arguments, the function will automatically assign them. 
For the sake of fast analysis, here we will use example dataset from `methrix`.

```{r}
print(basename(bdg_files))
```

The `read_bedgraphs` function adds CpGs missing from the reference set, and creates a methylation/coverage matrices. Once the process is complete - it returns an object of class `methrix` which in turn inherits `SummarizedExperiment` class. `methrix` object contains ‘methylation’ and ‘coverage’ matrices (either in-memory or as on-disk HDF5 arrays) along with pheno-data and other basic info. This object can be passed to all downstream functions for various analysis. For further details on the data structure, see the `SummarizedExperiment` package.

* For computers with large memory, increase speed using `vect=TRUE`. The function will open multiple files, defined by the `vect_batch_size` argument. Keep in mind, that increasing the batch size will increase the memory need as well. 

* If `vect=FALSE`, the function will iterate along the list of files, keeping only one open at a time. 

```{r, vect_read_in}
meth <- methrix::read_bedgraphs(
  files = bdg_files,
  ref_cpgs = hg19_cpgs,
  chr_idx = 1,
  start_idx = 2,
  M_idx = 3,
  U_idx = 4,
  stranded = FALSE,
  zero_based = FALSE, 
  collapse_strands = FALSE, 
  coldata = sample_anno,
  vect = TRUE,
  vect_batch_size = 4
)
```

**Potential pitfalls: **
Too many missing CpGs, if not expected, might indicate that something went wrong. 

* An obvious error is using the wrong reference genome. 

* A common mistake is falsely indicating strandedness and zero or one based positioning. The combination of the two might lead to only using C-s from one strand (due to a 1 bp shift), resulting lower coverage for the sites. A nice description of the zero- and one-based coordination system can be found [here](http://genome.ucsc.edu/blog/the-ucsc-genome-browser-coordinate-counting-systems/) 

## Initial QC and summary

Without any further processing, we can create an interactive html report containing basic summary statistics of the `methrix` object with `methrix_report` function. 

```{r, eval=FALSE}
methrix::methrix_report(meth = meth, output_dir = tempdir())
```

In the report, we can check genome-wide and chromosome based statistics on coverage and methylation, in order to identify potential quality issues, for example:

* samples with too high or too low genome-wide coverage or on a specific chromosome. In this case, there is also a possibility, that the sample is affected by copy number alterations. Both methylation levels and coverage therefore shows higher variation among cancer samples. 

* samples with altered beta level distribution. 

* A "bump" on the beta level density plot at 0.5 indicates the presence of single nucleotide polymorphisms (SNPs) -> see later.


## Filtering

### Coverage based filtering 

To ensure the high quality of our dataset, the sites with very low (untrustworthy methylation level) or high coverage (technical problem) should not be used. We can mask these CpG sites. Please note, that the DSS we were using for Differential Methylation Region (DMR) calling, doesn't need the removal of the lowly covered sites, because it takes it into account by analysis. However, using a not too restrictive threshold won't interfere with DMR calling. 

```{r mask_methrix}
meth <- methrix::mask_methrix(meth, low_count = 2, high_quantile = 0.99) 
```

Later we can remove those sites that are not covered by any of the samples. 

```{r remove_uncovered}
meth <- methrix::remove_uncovered(meth) 
```

We might want to remove the sites that are sparsely covered. If we plan to do differential analysis, we can do it group-wise, or using the whole population. 

```{r cov_filt}
meth <- methrix::coverage_filter(m=meth, cov_thr = 5, min_samples = 2)
#or
#meth <- methrix:coverage_filter(m=meth, cov_thr = 5, min_samples = 2, group="Condition")
```

### SNP filtering

SNPs, mostly the C > T mutations can disrupt methylation calling. Therefore it is essential to remove CpG sites that overlap with common variants, if we have variation in our study population. For example working with human, unpaired data, e.g. treated vs. untreated groups. 
During filtering, we can select the population of interest and the minimum minor allele frequency (MAF) of the SNPs.
SNP filtering is currently implemented for hg19 and hg38 assemblies. 


```{r message=FALSE, warning=FALSE}
if(!requireNamespace("GenomicScores")) {
BiocManager::install("GenomicScores")
}
library(GenomicScores) 
```

```{r remove_snps}
meth <- methrix::remove_snps(m = meth, keep = TRUE)
```
* There is a possibility to keep the sites possibly overlapping with SNPs. We can use this data for detecting possible sample mismatches. For this, we need to plot the most variable sites (probably the ones that are variable in our study population) and plot them on a heatmap. 

```{r}
if (!requireNamespace("pheatmap", quietly = TRUE))
    install.packages("pheatmap")

snps <- meth[[2]]
meth <- meth[[1]]

pheatmap::pheatmap(get_matrix(order_by_sd(snps)[1:min(5000, length(snps)),]))

```


* SNP removal in mouse data: 
  Usually, there is no need to remove SNPs from mouse data, since for many experiments, the same strain of mice is used. However, there are cases, when different crosses of strains are used, for which, the level of heterozygosity might be different. SNP data for mice can be downloaded from here: https://www.sanger.ac.uk/science/data/mouse-genomes-project. The SNPs can be filtered out using the `region filter` function. 
  
# Visualization and QC after filtering

## Methrix report
After filtering, it worth running a report again, to see if any of the samples were so lowly covered that it warrants an action (e.g. removal of the sample)

**Important:** Don't forget to set the `recal_stats` to `TRUE`, since the object changed since reading in. The output directory has to be different from last time, to avoid using the intermediate files calculated during the last run. 

```{r filtered_report, eval=FALSE}

methrix::methrix_report(meth = meth, output_dir = tempdir(), recal_stats = TRUE, prefix="processed")

```

There are additional possibilities to visualize the study. We can look at the density of coverage both sample- and group-wise: 

```{r fig.height=3, fig.width=4, message=FALSE, warning=FALSE}
methrix::plot_coverage(m = meth, type = "dens")
```


```{r fig.height=3, fig.width=4, message=FALSE, warning=FALSE}
methrix::plot_coverage(m = meth, type = "dens", pheno = "Condition", perGroup = TRUE)
```

We can visualize te beta value distribution as a violin plot or density plot. These plots (as well as the coverage plot) use the most variable 25000 CpG sites to ensure fast processing. `plot_density` and `plot_violin` has the option to use data only from a restricted region. 

```{r fig.height=3, fig.width=4, message=FALSE, warning=FALSE}
methrix::plot_density(m=meth)
```

```{r fig.height=3, fig.width=4, message=FALSE, warning=FALSE}
methrix::plot_density(m=meth, ranges = GRanges("chr22:48007313-49007313"))
```

## Dimensionality reduction 

`Methrix` offers principal component analysis (PCA) to conduct and visualize dimensionality reduction. 
As a first step, the PCA model has to be calculated. As for plotting, a given number of sites are selected, either random or based on variance (`var` option). This ensures that the calculations remain feasible. 

```{r, fig.height=3, fig.width=4}
mpca <- methrix::methrix_pca(m= meth, top_var = 10000, n_pc = 20)
```

At visualization, we can provide the `methrix` object to allow color or shape annotation of groups or samples.  

```{r, fig.height=3, fig.width=4}
methrix::plot_pca(mpca, m=meth, col_anno = "Condition", shape_anno = "Pair")
```

`methrix` offers the possibility of region based filtering. With this option, selected regions, e.g. promoters can be visualized. We will use the `annotatr` package to assess basic annotation categories. 

```{r message=FALSE, warning=FALSE}

if(!requireNamespace("annotatr")) {
BiocManager::install("annotatr", update = F)
}

```


```{r message=FALSE, warning=FALSE}
library(annotatr)
promoters = build_annotations(genome = 'hg19', annotations = "hg19_genes_promoters")
promoters
```

```{r fig.height=3, fig.width=4, message=FALSE, warning=FALSE}

mpca <- methrix::methrix_pca(m= meth, top_var = 10000, ranges = promoters, n_pc = 3, do_plot = F)
methrix::plot_pca(mpca, m=meth, col_anno = "Condition", shape_anno = "Pair")

```


# Differential methylation calling

## DSS
A very important step of a WGBS data analysis is the differential methylation calling. During this step, we would like to identify changes between groups or conditions first on the site level. Then, we will need to identify larger regions (DMR-s, differentially methylated regions) affected by methylation changes that are more likely to represent functional alterations. `Methrix` doesn't have a DMR caller, therefore we will use `DSS`. 
At this stage, `DSS` is not yet able to work directly with `methrix`, therefore we transform our methrix object to `bsseq` for the sake of DMR calling. 

```{r message=FALSE, warning=FALSE}

if(!requireNamespace("DSS")) {
BiocManager::install("DSS")
}
library(DSS)
```

For more detailed description, options and recommendations on smoothing, please refer to the ´DSS´ [vignette](https://bioconductor.org/packages/release/bioc/vignettes/DSS/inst/doc/DSS.html)

```{r message=FALSE, warning=FALSE, echo=T, results='hide'}

bs_obj <- methrix::methrix2bsseq(meth)

dmlTest = DSS::DMLtest(bs_obj, group1=c("C1", "C2"), group2=c("N1", "N2"), 
                       smoothing = TRUE)

```

### Call DMRs and DMLs 


```{r warning=FALSE, include=FALSE}

if(!requireNamespace("kableExtra")) {
install.packages("kableExtra")
}
if(!requireNamespace("magrittr")) {
install.packages("magrittr")
}

library(kableExtra)
library(magrittr)
```


```{r results=FALSE}

dmls = DSS::callDML(dmlTest, p.threshold = 0.05)
dmrs = DSS::callDMR(dmlTest, p.threshold = 0.05)

```

**DMRs:**

```{r}

kable(dmrs) %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  scroll_box(width = "100%", height = "200px")

```

**DMLs:**

```{r}

kable(dmls) %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  scroll_box(width = "100%", height = "200px")

```

# Visualizing DMRs and candidate regions


## Visualizing a region 
We can visualize certain regions and/or DMRs using the [Gviz](https://bioconductor.org/packages/release/bioc/html/Gviz.html) package. The plotting function is included in the best-practices.Rmd file.

```{r message=FALSE, warning=FALSE, include=FALSE}
if(!requireNamespace("Gviz")) {
BiocManager::install("Gviz")
}

if(!requireNamespace("biomaRt")) {
BiocManager::install("biomaRt")
}

library(Gviz)
library(biomaRt)
```


```{r include=FALSE}

region_plot <- function(m = meth, region=candidate_region, mart=mart, genome=genome, groups=NULL, dmrs=NULL){

  candidate_region <- GenomicRanges::flank(region, width = 1000, both = TRUE)

## Annotation data from biomart
biomartTrack <- BiomartGeneRegionTrack(biomart = mart,
                                           chromosome=as.character(seqnames(candidate_region)),
                                           start=start(candidate_region),
                                           end=end(candidate_region), name="ENSEMBL")
# make it nice
displayPars(biomartTrack) <- list(background.title="transparent",fontcolor="black", 
                                  fontcolor.title="black", fontcolor.legend="black", col="black", 
                                  col.line="black", cex=3)

#Prepare methylation data
beta <- get_matrix(methrix::subset_methrix(m, regions = candidate_region), add_loci=TRUE)
beta$end <- beta$start+1
beta <- makeGRangesFromDataFrame(beta, keep.extra.columns = T)


#idiogram
itrack <- IdeogramTrack(genome=genome, chromosome=as.character(seqnames(candidate_region)),
            cex=1.2, fontcolor="black")


### Prepare tracks with methylation data
if (!is.null(groups)){
methylation_track <-DataTrack(beta,
                              lwd = 2,
                              cex = 20,
                              type=c("p", "smooth"),
                              span=0.5,
                              legend=TRUE,
                              groups=groups,
                              aggregateGroups=TRUE,
                              aggregation="mean",
                              na.rm=TRUE, 
                              name = "Methylation")
} else {
  methylation_track <-DataTrack(beta,
                              lwd = 2,
                              cex = 20,
                              type=c("p", "smooth"),
                              span=0.5,
                              legend=TRUE,
                              name = "Methylation")
  
}


methylation_track_hm <-DataTrack(beta,
                                 lwd = 2,
                                 cex = 10,
                                 type="heatmap",
                                 ncolor=100,
                                 name = "Methylation heatmap", 
                                 showSampleNames=TRUE, cex.sampleNames=0.6)

displayPars(methylation_track) <- list(fontcolor="black", fontcolor.title="black", fontcolor.legend="black", 
                                       fill="white", col.axis="black", cex.title=0.5, 
                                       background.title="transparent", cex.legend=0.8, cex=0.1)

displayPars(methylation_track_hm) <- list(fontcolor="black", fontcolor.title="black", fontcolor.legend="black", 
                                           col.axis="black", cex.title =0.5, col.sampleNames="black", cex.sampleNames=0.5,
                                          background.title="transparent", cex.legend=1.2)

gtrack <- GenomeAxisTrack(fontcolor="black", col="black")
 

###annotation of DMRs, if needed
if (!is.null(dmrs)){
dmr_data <-  makeGRangesFromDataFrame(dmrs, keep.extra.columns = T)

DMR_track <- HighlightTrack(trackList=list(biomartTrack), start=start(dmr_data), width=width(dmr_data), chromosome=as.character(seqnames(candidate_region)))
DMR_track_2 <- HighlightTrack(trackList=list(methylation_track), start=start(dmr_data), width=width(dmr_data), chromosome=as.character(seqnames(candidate_region)))
displayPars(DMR_track) <- list(col="grey50", fill="lightgrey", alpha=0.50)
displayPars(DMR_track_2) <- list(col="grey50", fill="lightgrey", alpha=0.50)
} 

## plot the datatracks
if (is.null(dmrs)){
  tracklist <- list(itrack, gtrack, biomartTrack, methylation_track_hm, methylation_track)
 } else {
  tracklist <-  list(itrack, gtrack, DMR_track, methylation_track_hm, DMR_track_2)}
                   

try(plotTracks(tracklist, 
                      sizes=c(0.5,1.5,1,3,6),
                    from = start(candidate_region),
                    to = end(candidate_region),
                    transcriptAnnotation="symbol",
                    silent = T))
}

```

```{r fig.height=3, fig.width=5}
genome <- "hg19"
mart <- useMart(biomart="ENSEMBL_MART_ENSEMBL", host="feb2014.archive.ensembl.org", path="/biomart/martservice", dataset="hsapiens_gene_ensembl")


i <- 1

candidate_region <- GRanges(paste0(dmrs[i,"chr"], ":", dmrs[i,"start"], "-", dmrs[i,"end"]))
region_plot(m = meth, region=candidate_region, mart=mart, genome=genome, groups=meth$Condition, dmrs=dmrs)
#the region_plot function is available in the best_practices.Rmd file. 
```

## Heatmap of DMRs

```{r fig.height=4, fig.width=5, message=FALSE, warning=FALSE}

heatmap_data <- as.data.frame(methrix::get_region_summary(meth, dmrs))
heatmap_data <- heatmap_data[complete.cases(heatmap_data),]
rownames(heatmap_data) <- paste0(heatmap_data$chr,":", heatmap_data$start, "-", heatmap_data$end)
pheatmap::pheatmap(heatmap_data[,-(1:4)], show_rownames = TRUE, annotation_col = as.data.frame(meth@colData), 
                   fontsize = 8)

```

## Number and size of DMRs 

```{r message=FALSE, warning=FALSE}
if(!requireNamespace("plotly")) {
install.packages("plotly")
}
if(!requireNamespace("ggplot2")) {
install.packages("ggplot2")
}
if(!requireNamespace("scales")) {
install.packages("scales")
}
library(plotly)
library(ggplot2)
library(scales)
```

```{r fig.height=3, fig.width=5}

count <- c("Higher methylation in tumor" = nrow(dmrs[dmrs$diff.Methy<0,]),
           "Higher methylation in control" = nrow(dmrs[dmrs$diff.Methy>0,]))
length <- c("Higher methylation in tumor" = sum(dmrs[dmrs$diff.Methy<0,"length"]), 
            "Higher methylation in control" = sum(dmrs[dmrs$diff.Methy>0,"length"])) 


data <- data.frame(Direction=c("Gain", "Loss"), Count=count, Length=length)

   g <- ggplot(data=data)+geom_col(aes(x=factor(1), y=Count, fill=Direction), position = "dodge")+theme_bw()+theme(axis.title.x = element_blank(), axis.text.x = element_blank())+scale_fill_brewer(palette = "Dark2")+ggtitle("Number of differentially methylated regions")+scale_y_continuous(labels = comma)
ggplotly(g)
   p <- ggplot(data=data)+geom_col(aes(x=factor(1), y=Length, fill=Direction), position = "dodge")+theme_bw()+theme(axis.title.x = element_blank(), axis.text.x = element_blank())+scale_fill_brewer(palette = "Dark2")+ggtitle("Length of differentially methylated regions")+scale_y_continuous(labels = comma)
ggplotly(p)
   
```



# Region annotation 

To describe and interpret the differentially methylated regions, we can use the `ChIPseeker` package. The location of the DMRs can already give us a hint the involved processes, but once we assign the regions to genes, a pathway enrichment analysis is also possible. For additional details, see the [vignette](https://bioconductor.org/packages/release/bioc/vignettes/ChIPseeker/inst/doc/ChIPseeker.html) of `ChIPseeker`:  


```{r message=FALSE, warning=FALSE}
## loading packages
if(!requireNamespace("ChIPseeker")) {
BiocManager::install("ChIPseeker")
}
if(!requireNamespace("TxDb.Hsapiens.UCSC.hg19.knownGene")) {
BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
}
if(!requireNamespace("ReactomePA")) {
BiocManager::install("ReactomePA")
}
if(!requireNamespace("clusterProfiler")) {
BiocManager::install("clusterProfiler")
}
library(ChIPseeker)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
library(ReactomePA)
library(clusterProfiler)

```

```{r fig.height=3, fig.width=5}
 
 dmrs <- makeGRangesFromDataFrame(dmrs, keep.extra.columns = T)

 
  peakAnnoList <- lapply(list("Higher in tumor"=dmrs[dmrs$diff.Methy<0,], "Higher in normal" = dmrs[dmrs$diff.Methy>0,]), annotatePeak, TxDb=txdb, tssRegion=c(-3000, 3000), verbose=FALSE)

plotAnnoBar(peakAnnoList)
plotDistToTSS(peakAnnoList)



genes <- lapply(list("Higher in tumor"=dmrs[dmrs$diff.Methy<0,], "Higher in normal" = dmrs[1:3,]), seq2gene, tssRegion = c(-1000, 1000), flankDistance = 3000, TxDb=txdb)

names(genes) <- gsub(" ", "\n", names(genes))
comppthw <- compareCluster(geneCluster   = genes,
                         fun           = "enrichPathway",
                         pvalueCutoff  = 0.05,
                         pAdjustMethod = "BH")
dotplot(comppthw, font.size = 8)


```


# Working with HDF5-based object



## `read_bedgraph` function 
For memory efficient read in, one can use an HDF5 based `methrix` object. Only one bedgraph file is in the memory at the same time, while the resulting object won't be stored in the memory, but on-disk. 
Additional arguments to use HDF5:
- Set h5=TRUE 
- Set `vect=FALSE`
- h5_dir --> a directory to save the final object. It is possible to save the object later. It increases the processing time significantly.  
- h5temp --> a temporary directory to use during data processing. Set this if for example the default temporary location doesn't have enough free space to store the temporary data. 


```{r hdf5_read_in, eval=TRUE, include=TRUE}
meth <- methrix::read_bedgraphs(
  files = bdg_files,
  ref_cpgs = hg19_cpgs,
  chr_idx = 1,
  start_idx = 2,
  M_idx = 3,
  U_idx = 4,
  stranded = FALSE,
  zero_based = FALSE, 
  collapse_strands = FALSE, 
  coldata = sample_anno,
  vect = FALSE,
  h5 = TRUE)
```


## Working with HDF5-based objects

All `methrix` functions work with HDF5-based objects as well, there is no difference in using different functions. 

```{r}
meth <- methrix::remove_uncovered(meth)
```

It is also possible to transform non-HDF5-based objects to HDF5-based ones and back. 

```{r}

m <- convert_HDF5_methrix(m=meth)
m2 <- convert_methrix(m=m)
```


## Saving and loading

Saving and loading of an HDF5-based object is not possible using the standard save or saveRDS functions. `methrix` offers easy to use saving and loading tools, which are essentially wrappers around the `saveHDF5SummarizedExperiment` and `loadHDF5SummarizedExperiment` functions. 


```{r}

target_dir = paste0( tempdir(), '/temp/')
save_HDF5_methrix(meth, dir = target_dir, replace = TRUE)

meth <- load_HDF5_methrix(dir = target_dir)

```



